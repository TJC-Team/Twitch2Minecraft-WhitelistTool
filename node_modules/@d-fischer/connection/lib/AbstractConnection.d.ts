import type { Logger } from '@d-fischer/logger';
import type { EventHandler } from '@d-fischer/typed-event-emitter';
import { EventEmitter } from '@d-fischer/typed-event-emitter';
import type { Connection, ConnectionInfo } from './Connection';
export declare abstract class AbstractConnection extends EventEmitter implements Connection {
    protected readonly _host: string;
    protected readonly _port: number;
    protected readonly _secure: boolean;
    private readonly _lineBased;
    protected readonly _logger?: Logger;
    private _currentLine;
    protected _connecting: boolean;
    protected _connected: boolean;
    protected _manualDisconnect: boolean;
    readonly onReceive: (handler: EventHandler<[string]>) => import("@d-fischer/typed-event-emitter/lib").Listener;
    readonly onConnect: (handler: EventHandler<[]>) => import("@d-fischer/typed-event-emitter/lib").Listener;
    readonly onDisconnect: (handler: EventHandler<[boolean, (Error | undefined)?]>) => import("@d-fischer/typed-event-emitter/lib").Listener;
    readonly onEnd: (handler: EventHandler<[boolean, (Error | undefined)?]>) => import("@d-fischer/typed-event-emitter/lib").Listener;
    constructor({ hostName, port, secure, lineBased }: ConnectionInfo, logger?: Logger);
    get isConnecting(): boolean;
    get isConnected(): boolean;
    get host(): string;
    sendLine(line: string): void;
    abstract connect(): Promise<void>;
    abstract disconnect(): Promise<void>;
    assumeExternalDisconnect(): void;
    protected receiveRaw(data: string): void;
    protected abstract sendRaw(line: string): void;
    abstract get hasSocket(): boolean;
    abstract get port(): number;
}
