import { __read } from "tslib";
// eslint-disable-next-line @typescript-eslint/no-require-imports
import escapeRegexString from '@d-fischer/escape-string-regexp';
import { splitWithLimit } from '@d-fischer/shared-utils';
export function sanitizeParameter(param, spaceAllowed) {
    if (spaceAllowed === void 0) { spaceAllowed = false; }
    if (spaceAllowed) {
        return param.replace(/[\0\r\n]/g, '');
    }
    else {
        return param.replace(/[\0\r\n ]/g, '');
    }
}
export function isChannel(str, validTypes) {
    if (validTypes === void 0) { validTypes = '#&'; }
    var re = new RegExp("^[" + escapeRegexString(validTypes) + "][^ \b\0\n\r,]+$");
    return re.test(str);
}
var ctcpEscapeMap = {
    0: '\0',
    n: '\n',
    r: '\r',
    '\x10': '\x10'
};
export function decodeCtcp(message) {
    if (message[0] !== '\x01') {
        // this is not a CTCP message
        return false;
    }
    message = message.substring(1);
    // remove trailing \x01 if present
    if (message.slice(-1) === '\x01') {
        message = message.slice(0, -1);
    }
    if (!message) {
        // completely empty CTCPs don't exist either, I think
        return false;
    }
    // unescape weirdly escaped stuff
    message = message.replace(/\x10(.)/, function (_, escapedChar) {
        return escapedChar in ctcpEscapeMap ? ctcpEscapeMap[escapedChar] : '';
    });
    var _a = __read(splitWithLimit(message, ' ', 2), 2), command = _a[0], _b = _a[1], params = _b === void 0 ? '' : _b;
    command = command ? command.toUpperCase() : '';
    return { command: command, params: params };
}
