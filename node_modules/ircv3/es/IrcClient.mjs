import { __assign, __awaiter, __decorate, __extends, __generator, __read, __spread, __values } from "tslib";
import { DirectConnection, PersistentConnection, WebSocketConnection } from '@d-fischer/connection';
import { klona } from 'klona/json';
import { Logger } from '@d-fischer/logger';
import { arrayToObject, Enumerable, forEachObjectEntry, padLeft, resolveConfigValue, splitWithLimit } from '@d-fischer/shared-utils';
import { EventEmitter } from '@d-fischer/typed-event-emitter';
import * as CoreCapabilities from "./Capability/CoreCapabilities/index.mjs";
import { MessageError } from "./Errors/MessageError.mjs";
import { createMessage } from "./Message/Message.mjs";
import { MessageCollector } from "./Message/MessageCollector.mjs";
import { parseMessage } from "./Message/MessageParser.mjs";
import * as MessageTypes from "./Message/MessageTypes/index.mjs";
import { CapabilityNegotiation, ChannelJoin, ChannelPart, ClientQuit, ErrorMessage, NickChange, Notice, Password, Ping, Pong, PrivateMessage, UserRegistration } from "./Message/MessageTypes/Commands/index.mjs";
import { Error422NoMotd, Error462AlreadyRegistered, Reply001Welcome, Reply004ServerInfo, Reply005Isupport, Reply376EndOfMotd } from "./Message/MessageTypes/Numerics/index.mjs";
import { defaultServerProperties } from "./ServerProperties.mjs";
import { decodeCtcp } from "./Toolkit/StringTools.mjs";
var IrcClient = /** @class */ (function (_super) {
    __extends(IrcClient, _super);
    function IrcClient(options) {
        var e_1, _a;
        var _this = _super.call(this) || this;
        _this._registered = false;
        _this._supportsCapabilities = true;
        _this._events = new Map();
        _this._registeredMessageTypes = new Map();
        // emitted events
        _this.onConnect = _this.registerEvent();
        _this.onRegister = _this.registerEvent();
        _this.onDisconnect = _this.registerEvent();
        _this.onPrivmsg = _this.registerEvent();
        _this.onAction = _this.registerEvent();
        _this.onNotice = _this.registerEvent();
        _this.onNickChange = _this.registerEvent();
        _this.onCtcp = _this.registerEvent();
        _this.onCtcpReply = _this.registerEvent();
        _this.onAnyMessage = _this.registerEvent();
        _this._serverProperties = klona(defaultServerProperties);
        _this._supportedFeatures = {};
        _this._collectors = [];
        _this._clientCapabilities = new Map();
        _this._serverCapabilities = new Map();
        _this._negotiatedCapabilities = new Map();
        _this._initialConnectionSetupDone = false;
        var connection = options.connection, credentials = options.credentials, channels = options.channels, channelTypes = options.channelTypes, webSocket = options.webSocket, _b = options.logger, logger = _b === void 0 ? {} : _b;
        _this._options = options;
        var _c = connection.pingOnInactivity, pingOnInactivity = _c === void 0 ? 60 : _c, _d = connection.pingTimeout, pingTimeout = _d === void 0 ? 10 : _d;
        _this._pingOnInactivity = pingOnInactivity;
        _this._pingTimeout = pingTimeout;
        _this._currentNick = credentials.nick;
        _this._logger = new Logger(__assign({ name: 'ircv3', emoji: true }, logger));
        _this.registerCoreMessageTypes();
        var hostName = connection.hostName, secure = connection.secure, _e = connection.reconnect, reconnect = _e === void 0 ? true : _e;
        var connectionOptions = {
            hostName: hostName,
            port: _this.port,
            secure: secure,
            lineBased: true
        };
        var ConnectionType = webSocket ? WebSocketConnection : DirectConnection;
        if (reconnect) {
            _this._connection = new PersistentConnection(ConnectionType, connectionOptions, { logger: _this._logger });
        }
        else {
            _this._connection = new ConnectionType(connectionOptions, _this._logger);
        }
        try {
            for (var _f = __values(Object.values(CoreCapabilities)), _g = _f.next(); !_g.done; _g = _f.next()) {
                var cap = _g.value;
                _this.addCapability(cap);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (channels) {
            _this.onRegister(function () { return __awaiter(_this, void 0, void 0, function () {
                var resolvedChannels, resolvedChannels_1, resolvedChannels_1_1, channel;
                var e_2, _a;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, resolveConfigValue(channels)];
                        case 1:
                            resolvedChannels = _b.sent();
                            if (resolvedChannels) {
                                try {
                                    for (resolvedChannels_1 = __values(resolvedChannels), resolvedChannels_1_1 = resolvedChannels_1.next(); !resolvedChannels_1_1.done; resolvedChannels_1_1 = resolvedChannels_1.next()) {
                                        channel = resolvedChannels_1_1.value;
                                        this.join(channel);
                                    }
                                }
                                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                                finally {
                                    try {
                                        if (resolvedChannels_1_1 && !resolvedChannels_1_1.done && (_a = resolvedChannels_1.return)) _a.call(resolvedChannels_1);
                                    }
                                    finally { if (e_2) throw e_2.error; }
                                }
                            }
                            return [2 /*return*/];
                    }
                });
            }); });
        }
        _this.onTypedMessage(CapabilityNegotiation, function (_a) {
            var _b = _a.params, subCommand = _b.subCommand, capabilities = _b.capabilities;
            return __awaiter(_this, void 0, void 0, function () {
                var caps, _c, capList, _d, _e, _f, name, cap, capNames_1, caps_1, caps_1_1, cap;
                var e_3, _g, e_4, _h;
                return __generator(this, function (_j) {
                    switch (_j.label) {
                        case 0:
                            caps = capabilities.split(' ');
                            _c = subCommand.toUpperCase();
                            switch (_c) {
                                case 'NEW': return [3 /*break*/, 1];
                                case 'DEL': return [3 /*break*/, 3];
                            }
                            return [3 /*break*/, 4];
                        case 1:
                            this._logger.debug("Server registered new capabilities: " + caps.join(', '));
                            capList = arrayToObject(caps, function (part) {
                                var _a;
                                if (!part) {
                                    return {};
                                }
                                var _b = __read(splitWithLimit(part, '=', 2), 2), cap = _b[0], param = _b[1];
                                return _a = {},
                                    _a[cap] = {
                                        name: cap,
                                        param: param || true
                                    },
                                    _a;
                            });
                            try {
                                for (_d = __values(Object.entries(capList)), _e = _d.next(); !_e.done; _e = _d.next()) {
                                    _f = __read(_e.value, 2), name = _f[0], cap = _f[1];
                                    this._serverCapabilities.set(name, cap);
                                }
                            }
                            catch (e_3_1) { e_3 = { error: e_3_1 }; }
                            finally {
                                try {
                                    if (_e && !_e.done && (_g = _d.return)) _g.call(_d);
                                }
                                finally { if (e_3) throw e_3.error; }
                            }
                            capNames_1 = Object.keys(capList);
                            return [4 /*yield*/, this._negotiateCapabilities(Array.from(this._clientCapabilities.entries())
                                    .filter(function (_a) {
                                    var _b = __read(_a, 1), name = _b[0];
                                    return capNames_1.includes(name);
                                })
                                    .map(function (_a) {
                                    var _b = __read(_a, 2), cap = _b[1];
                                    return cap;
                                }))];
                        case 2:
                            _j.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            {
                                this._logger.debug("Server removed capabilities: " + caps.join(', '));
                                try {
                                    for (caps_1 = __values(caps), caps_1_1 = caps_1.next(); !caps_1_1.done; caps_1_1 = caps_1.next()) {
                                        cap = caps_1_1.value;
                                        this._serverCapabilities.delete(cap);
                                        this._negotiatedCapabilities.delete(cap);
                                    }
                                }
                                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                                finally {
                                    try {
                                        if (caps_1_1 && !caps_1_1.done && (_h = caps_1.return)) _h.call(caps_1);
                                    }
                                    finally { if (e_4) throw e_4.error; }
                                }
                            }
                            _j.label = 4;
                        case 4: return [2 /*return*/];
                    }
                });
            });
        });
        _this.onTypedMessage(Ping, function (_a) {
            var message = _a.params.message;
            _this.sendMessage(Pong, { message: message });
        });
        _this.onTypedMessage(Reply001Welcome, function (_a) {
            var me = _a.params.me;
            _this._handleReceivedClientNick(me);
        });
        _this.onTypedMessage(Reply004ServerInfo, function (_a) {
            var userModes = _a.params.userModes;
            if (userModes) {
                _this._serverProperties.supportedUserModes = userModes;
            }
        });
        _this.onTypedMessage(Reply005Isupport, function (_a) {
            var supports = _a.params.supports;
            var newFeatures = arrayToObject(supports.split(' '), function (part) {
                var _a;
                var _b = __read(splitWithLimit(part, '=', 2), 2), support = _b[0], param = _b[1];
                return _a = {}, _a[support] = param || true, _a;
            });
            _this._supportedFeatures = __assign(__assign({}, _this._supportedFeatures), newFeatures);
        });
        _this.onTypedMessage(Reply376EndOfMotd, function (_a) {
            var me = _a.params.me;
            if (!_this._registered) {
                _this._handleReceivedClientNick(me);
                _this._registered = true;
                _this.emit(_this.onRegister);
            }
        });
        _this.onTypedMessage(Error422NoMotd, function (_a) {
            var me = _a.params.me;
            if (!_this._registered) {
                _this._handleReceivedClientNick(me);
                _this._registered = true;
                _this.emit(_this.onRegister);
            }
        });
        _this.onTypedMessage(Error462AlreadyRegistered, function (_a) {
            var me = _a.params.me;
            // what, I thought we are not registered yet?
            if (!_this._registered) {
                // screw this, we are now.
                _this._logger.warn("We thought we're not registered yet, but we actually are");
                _this._handleReceivedClientNick(me);
                _this._registered = true;
                _this.emit(_this.onRegister);
            }
        });
        _this.onTypedMessage(PrivateMessage, function (msg) {
            var _a = msg.params, target = _a.target, message = _a.message;
            var ctcpMessage = decodeCtcp(message);
            var nick = msg.prefix && msg.prefix.nick;
            if (ctcpMessage) {
                if (ctcpMessage.command === 'ACTION') {
                    _this.emit(_this.onAction, target, nick, ctcpMessage.params, msg);
                }
                else {
                    _this.emit(_this.onCtcp, target, nick, ctcpMessage.command, ctcpMessage.params, msg);
                }
            }
            else {
                _this.emit(_this.onPrivmsg, target, nick, message, msg);
            }
        });
        _this.onTypedMessage(NickChange, function (msg) {
            var newNick = msg.params.nick;
            var oldNick = msg.prefix && msg.prefix.nick;
            if (oldNick === _this._currentNick) {
                _this._currentNick = newNick;
            }
            _this.emit(_this.onNickChange, oldNick, newNick, msg);
        });
        _this.onTypedMessage(Notice, function (msg) {
            var _a = msg.params, target = _a.target, message = _a.message;
            var ctcpMessage = decodeCtcp(message);
            var nick = msg.prefix && msg.prefix.nick;
            if (ctcpMessage) {
                _this.emit(_this.onCtcpReply, target, nick, ctcpMessage.command, ctcpMessage.params, msg);
            }
            _this.emit(_this.onNotice, target, nick, message, msg);
        });
        _this.onRegister(function () { return _this._startPingCheckTimer(); });
        _this._credentials = __assign({}, credentials);
        if (channelTypes) {
            _this._serverProperties.channelTypes = channelTypes;
        }
        return _this;
    }
    IrcClient.prototype.receiveLine = function (line) {
        this._logger.debug("Received message: " + line);
        var parsedMessage;
        try {
            parsedMessage = parseMessage(line, this._serverProperties, this._registeredMessageTypes, true, this._options.nonConformingCommands);
        }
        catch (e) {
            this._logger.err("Error parsing message: " + e.message);
            this._logger.trace(e.stack);
            return;
        }
        this._logger.trace("Parsed message: " + JSON.stringify(parsedMessage));
        this._startPingCheckTimer();
        this.emit(this.onAnyMessage, parsedMessage);
        this._handleEvents(parsedMessage);
    };
    Object.defineProperty(IrcClient.prototype, "serverProperties", {
        get: function () {
            return klona(this._serverProperties);
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IrcClient.prototype, "port", {
        get: function () {
            var _a = this._options, webSocket = _a.webSocket, _b = _a.connection, port = _b.port, secure = _b.secure;
            if (port) {
                return port;
            }
            if (webSocket) {
                return secure ? 443 : 80;
            }
            return secure ? 6697 : 6667;
        },
        enumerable: false,
        configurable: true
    });
    IrcClient.prototype.pingCheck = function () {
        var _this = this;
        var now = Date.now();
        var nowStr = now.toString();
        var handler = this.onTypedMessage(Pong, function (msg) {
            var message = msg.params.message;
            if (message === nowStr) {
                _this._logger.debug("Current ping: " + (Date.now() - now) + "ms");
                if (_this._pingTimeoutTimer) {
                    clearTimeout(_this._pingTimeoutTimer);
                }
                _this.removeMessageListener(handler);
            }
        });
        this._pingTimeoutTimer = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.removeMessageListener(handler);
                // eslint-disable-next-line no-restricted-syntax
                if (this._options.connection.reconnect === false) {
                    this._logger.error("Disconnecting because the last ping took over " + this._pingTimeout + " seconds");
                }
                else {
                    this._logger.warn("Reconnecting because the last ping took over " + this._pingTimeout + " seconds");
                }
                this._connection.assumeExternalDisconnect();
                return [2 /*return*/];
            });
        }); }, this._pingTimeout * 1000);
        this.sendMessage(Ping, { message: nowStr });
    };
    IrcClient.prototype.reconnect = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.quit(message)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.connect()];
                }
            });
        });
    };
    IrcClient.prototype.registerMessageType = function (cls) {
        if (cls.COMMAND !== '') {
            this._logger.trace("Registering message type " + cls.COMMAND);
            this._registeredMessageTypes.set(cls.COMMAND.toUpperCase(), cls);
        }
    };
    IrcClient.prototype.knowsCommand = function (command) {
        return this._registeredMessageTypes.has(command.toUpperCase());
    };
    IrcClient.prototype.getCommandClass = function (command) {
        return this._registeredMessageTypes.get(command.toUpperCase());
    };
    IrcClient.prototype.connect = function () {
        return __awaiter(this, void 0, Promise, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._supportsCapabilities = false;
                        this._negotiatedCapabilities = new Map();
                        this._currentNick = this._credentials.nick;
                        return [4 /*yield*/, this._setupConnection()];
                    case 1:
                        _a.sent();
                        this._logger.info("Connecting to " + this._connection.host + ":" + this._connection.port);
                        return [4 /*yield*/, this._connection.connect()];
                    case 2:
                        _a.sent();
                        this.emit(this.onConnect);
                        return [2 /*return*/];
                }
            });
        });
    };
    IrcClient.prototype.waitForRegistration = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this._registered) {
                    return [2 /*return*/, undefined];
                }
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var errorListener;
                        var disconnectListener;
                        var registerListener = _this.onRegister(function () {
                            registerListener.unbind();
                            _this.removeMessageListener(errorListener);
                            disconnectListener.unbind();
                            resolve();
                        });
                        errorListener = _this.onTypedMessage(ErrorMessage, function (msg) {
                            registerListener.unbind();
                            _this.removeMessageListener(errorListener);
                            disconnectListener.unbind();
                            reject(new MessageError(msg));
                        });
                        disconnectListener = _this.onDisconnect(function (reason) {
                            registerListener.unbind();
                            _this.removeMessageListener(errorListener);
                            disconnectListener.unbind();
                            reject(reason);
                        });
                    })];
            });
        });
    };
    IrcClient.prototype.addCapability = function (cap) {
        var e_5, _a;
        this._clientCapabilities.set(cap.name, cap);
        if (cap.messageTypes) {
            try {
                for (var _b = __values(cap.messageTypes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var messageType = _c.value;
                    this.registerMessageType(messageType);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_5) throw e_5.error; }
            }
        }
    };
    IrcClient.prototype.registerCapability = function (cap) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.addCapability(cap);
                if (this._serverCapabilities.has(cap.name)) {
                    return [2 /*return*/, this._negotiateCapabilities([cap])];
                }
                return [2 /*return*/, []];
            });
        });
    };
    IrcClient.prototype.send = function (message) {
        this.sendRaw(message.toString());
    };
    IrcClient.prototype.sendRaw = function (line) {
        if (this._connection.isConnected) {
            this._logger.debug("Sending message: " + line);
            this._connection.sendLine(line);
        }
    };
    IrcClient.prototype.onNamedMessage = function (commandName, handler, handlerName) {
        if (!this._events.has(commandName)) {
            this._events.set(commandName, new Map());
        }
        var handlerList = this._events.get(commandName);
        if (!handlerName) {
            do {
                handlerName = commandName + ":" + padLeft(Math.random() * 10000, 4, '0');
            } while (handlerList.has(handlerName));
        }
        handlerList.set(handlerName, handler);
        return handlerName;
    };
    IrcClient.prototype.onTypedMessage = function (type, handler, handlerName) {
        return this.onNamedMessage(type.COMMAND, handler, handlerName);
    };
    IrcClient.prototype.removeMessageListener = function (handlerName) {
        var _a = __read(handlerName.split(':'), 1), commandName = _a[0];
        if (!this._events.has(commandName)) {
            return;
        }
        this._events.get(commandName).delete(handlerName);
    };
    IrcClient.prototype.createMessage = function (type, params, tags) {
        var tagsMap = tags ? new Map(Object.entries(tags)) : undefined;
        return createMessage(type, params, undefined, tagsMap, this.serverProperties);
    };
    IrcClient.prototype.sendMessage = function (type, params, tags) {
        this.send(this.createMessage(type, params, tags));
    };
    IrcClient.prototype.sendMessageAndCaptureReply = function (type, params) {
        return __awaiter(this, void 0, Promise, function () {
            var message, promise;
            return __generator(this, function (_a) {
                if (!type.SUPPORTS_CAPTURE) {
                    throw new Error("The command \"" + type.COMMAND + "\" does not support reply capture");
                }
                message = this.createMessage(type, params);
                promise = this.collect(message).promise();
                this.send(message);
                return [2 /*return*/, promise];
            });
        });
    };
    Object.defineProperty(IrcClient.prototype, "isConnected", {
        get: function () {
            return this._connection.isConnected;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IrcClient.prototype, "isConnecting", {
        get: function () {
            return this._connection.isConnecting;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IrcClient.prototype, "isRegistered", {
        get: function () {
            return this._registered;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(IrcClient.prototype, "currentNick", {
        get: function () {
            return this._currentNick;
        },
        enumerable: false,
        configurable: true
    });
    /** @private */
    IrcClient.prototype.collect = function (originalMessage) {
        var types = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            types[_i - 1] = arguments[_i];
        }
        var collector = new (MessageCollector.bind.apply(MessageCollector, __spread([void 0, this, originalMessage], types)))();
        this._collectors.push(collector);
        return collector;
    };
    /** @private */
    IrcClient.prototype.stopCollect = function (collector) {
        this._collectors.splice(this._collectors.findIndex(function (value) { return value === collector; }), 1);
    };
    // convenience methods
    IrcClient.prototype.join = function (channel, key) {
        this.sendMessage(ChannelJoin, { channel: channel, key: key });
    };
    IrcClient.prototype.part = function (channel) {
        this.sendMessage(ChannelPart, { channel: channel });
    };
    IrcClient.prototype.quit = function (message) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                this.sendMessage(ClientQuit, { message: message });
                this._connection.disconnect().then(function () {
                    _this._logger.debug('Finished cleaning up old connection');
                });
                return [2 /*return*/];
            });
        });
    };
    IrcClient.prototype.say = function (target, message, tags) {
        if (tags === void 0) { tags = {}; }
        this.sendMessage(PrivateMessage, { target: target, message: message }, tags);
    };
    IrcClient.prototype.sendCtcp = function (target, type, message) {
        this.say(target, "\u0001" + type.toUpperCase() + " " + message + "\u0001");
    };
    IrcClient.prototype.action = function (target, message) {
        this.sendCtcp(target, 'ACTION', message);
    };
    IrcClient.prototype.getPassword = function (currentPassword) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, currentPassword];
            });
        });
    };
    IrcClient.prototype.registerCoreMessageTypes = function () {
        var _this = this;
        forEachObjectEntry(MessageTypes.Commands, function (type) {
            _this.registerMessageType(type);
        });
        forEachObjectEntry(MessageTypes.Numerics, function (type) {
            _this.registerMessageType(type);
        });
    };
    IrcClient.prototype._negotiateCapabilityBatch = function (capabilities) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, Promise.all(capabilities
                        .filter(function (list) { return list.length; })
                        .map(function (capList) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                        return [2 /*return*/, this._negotiateCapabilities(capList)];
                    }); }); }))];
            });
        });
    };
    IrcClient.prototype._negotiateCapabilities = function (capList) {
        return __awaiter(this, void 0, Promise, function () {
            var mappedCapList, messages, capReply, negotiatedCapNames, newNegotiatedCaps, newNegotiatedCaps_1, newNegotiatedCaps_1_1, newCap, mergedCap;
            var e_6, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        mappedCapList = arrayToObject(capList, function (cap) {
                            var _a;
                            return (_a = {},
                                _a[cap.name] = cap,
                                _a);
                        });
                        return [4 /*yield*/, this.sendMessageAndCaptureReply(CapabilityNegotiation, {
                                subCommand: 'REQ',
                                capabilities: capList.map(function (cap) { return cap.name; }).join(' ')
                            })];
                    case 1:
                        messages = _b.sent();
                        capReply = messages.shift();
                        if (!capReply) {
                            throw new Error('capability negotiation failed unexpectedly without any reply');
                        }
                        if (!(capReply instanceof CapabilityNegotiation)) {
                            throw new Error("capability negotiation failed unexpectedly with \"" + capReply.command + "\" command");
                        }
                        negotiatedCapNames = capReply.params.capabilities.split(' ').filter(function (c) { return c; });
                        if (capReply.params.subCommand === 'ACK') {
                            // filter is necessary because some networks seem to add trailing spaces...
                            this._logger.debug("Successfully negotiated capabilities: " + negotiatedCapNames.join(', '));
                            newNegotiatedCaps = negotiatedCapNames.map(function (capName) { return mappedCapList[capName]; });
                            try {
                                for (newNegotiatedCaps_1 = __values(newNegotiatedCaps), newNegotiatedCaps_1_1 = newNegotiatedCaps_1.next(); !newNegotiatedCaps_1_1.done; newNegotiatedCaps_1_1 = newNegotiatedCaps_1.next()) {
                                    newCap = newNegotiatedCaps_1_1.value;
                                    mergedCap = this._clientCapabilities.get(newCap.name);
                                    mergedCap.param = newCap.param;
                                    this._negotiatedCapabilities.set(mergedCap.name, mergedCap);
                                }
                            }
                            catch (e_6_1) { e_6 = { error: e_6_1 }; }
                            finally {
                                try {
                                    if (newNegotiatedCaps_1_1 && !newNegotiatedCaps_1_1.done && (_a = newNegotiatedCaps_1.return)) _a.call(newNegotiatedCaps_1);
                                }
                                finally { if (e_6) throw e_6.error; }
                            }
                            return [2 /*return*/, newNegotiatedCaps];
                        }
                        else {
                            this._logger.warn("Failed to negotiate capabilities: " + negotiatedCapNames.join(', '));
                            return [2 /*return*/, new Error('capabilities failed to negotiate')];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    IrcClient.prototype._updateCredentials = function (newCredentials) {
        this._credentials = __assign(__assign({}, this._credentials), newCredentials);
    };
    IrcClient.prototype._setupConnection = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this._initialConnectionSetupDone) {
                    return [2 /*return*/];
                }
                this._connection.onConnect(function () { return __awaiter(_this, void 0, void 0, function () {
                    var _a, password;
                    var _this = this;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                this._logger.info("Connection to server " + this._connection.host + ":" + this._connection.port + " established");
                                this._logger.debug('Determining connection password');
                                return [4 /*yield*/, Promise.all([
                                        this.getPassword(this._credentials.password),
                                        this.sendMessageAndCaptureReply(CapabilityNegotiation, {
                                            subCommand: 'LS',
                                            version: '302'
                                        })
                                            .then(function (capReply) {
                                            if (!capReply.length || !(capReply[0] instanceof CapabilityNegotiation)) {
                                                _this._logger.debug('Server does not support capabilities');
                                                return [];
                                            }
                                            _this._supportsCapabilities = true;
                                            var capLists = capReply.map(function (line) {
                                                return arrayToObject(line.params.capabilities.split(' '), function (part) {
                                                    var _a;
                                                    if (!part) {
                                                        return {};
                                                    }
                                                    var _b = __read(splitWithLimit(part, '=', 2), 2), cap = _b[0], param = _b[1];
                                                    return _a = {},
                                                        _a[cap] = {
                                                            name: cap,
                                                            param: param || true
                                                        },
                                                        _a;
                                                });
                                            });
                                            _this._serverCapabilities = new Map(Object.entries(Object.assign.apply(Object, __spread([{}], capLists))));
                                            _this._logger.debug("Capabilities supported by server: " + Array.from(_this._serverCapabilities.keys()).join(', '));
                                            var capabilitiesToNegotiate = capLists.map(function (list) {
                                                var capNames = Object.keys(list);
                                                return Array.from(_this._clientCapabilities.entries())
                                                    .filter(function (_a) {
                                                    var _b = __read(_a, 1), name = _b[0];
                                                    return capNames.includes(name);
                                                })
                                                    .map(function (_a) {
                                                    var _b = __read(_a, 2), cap = _b[1];
                                                    return cap;
                                                });
                                            });
                                            return _this._negotiateCapabilityBatch(capabilitiesToNegotiate);
                                        })
                                            .then(function () {
                                            _this.sendMessage(CapabilityNegotiation, { subCommand: 'END' });
                                        })
                                    ])];
                            case 1:
                                _a = __read.apply(void 0, [_b.sent(), 1]), password = _a[0];
                                if (password && password !== this._credentials.password) {
                                    this._updateCredentials({ password: password });
                                }
                                if (password) {
                                    this.sendMessage(Password, { password: password });
                                }
                                this.sendMessage(NickChange, { nick: this._credentials.nick });
                                this.sendMessage(UserRegistration, {
                                    user: this._credentials.userName || this._credentials.nick,
                                    mode: '8',
                                    unused: '*',
                                    realName: this._credentials.realName || this._credentials.nick
                                });
                                return [2 /*return*/];
                        }
                    });
                }); });
                this._initialConnectionSetupDone = true;
                this._connection.onReceive(function (line) {
                    _this.receiveLine(line);
                });
                this._connection.onDisconnect(function (manually, reason) {
                    _this._registered = false;
                    if (_this._pingCheckTimer) {
                        clearTimeout(_this._pingCheckTimer);
                    }
                    if (_this._pingTimeoutTimer) {
                        clearTimeout(_this._pingTimeoutTimer);
                    }
                    if (manually) {
                        _this._logger.info('Disconnected');
                    }
                    else {
                        if (reason) {
                            _this._logger.err("Disconnected unexpectedly: " + reason.message);
                        }
                        else {
                            _this._logger.err('Disconnected unexpectedly');
                        }
                    }
                    _this.emit(_this.onDisconnect, manually, reason);
                });
                // eslint-disable-next-line no-restricted-syntax
                if (this._options.connection.reconnect !== false) {
                    this._connection.onEnd(function (manually) {
                        if (!manually) {
                            _this._logger.info('No further retries will be made');
                        }
                    });
                }
                return [2 /*return*/];
            });
        });
    };
    IrcClient.prototype._handleReceivedClientNick = function (me) {
        if (this._currentNick !== me) {
            if (this._currentNick !== '') {
                this._logger.warn("Mismatching nicks: passed " + this._currentNick + ", but you're actually " + me);
            }
            this._currentNick = me;
        }
    };
    // event helper
    IrcClient.prototype._handleEvents = function (message) {
        var e_7, _a;
        this._collectors.some(function (collector) { return collector.collect(message); });
        var handlers = this._events.get(message.constructor.COMMAND);
        if (!handlers) {
            return;
        }
        try {
            for (var _b = __values(handlers.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var handler = _c.value;
                handler(message);
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
    };
    IrcClient.prototype._startPingCheckTimer = function () {
        var _this = this;
        if (this._pingCheckTimer) {
            clearTimeout(this._pingCheckTimer);
        }
        if (this._connection.isConnected) {
            this._pingCheckTimer = setTimeout(function () { return _this.pingCheck(); }, this._pingOnInactivity * 1000);
        }
        else {
            this._pingCheckTimer = undefined;
        }
    };
    __decorate([
        Enumerable(false)
    ], IrcClient.prototype, "_options", void 0);
    __decorate([
        Enumerable(false)
    ], IrcClient.prototype, "_credentials", void 0);
    return IrcClient;
}(EventEmitter));
export { IrcClient };
