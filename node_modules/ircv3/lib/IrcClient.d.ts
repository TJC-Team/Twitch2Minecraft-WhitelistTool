/// <reference types="node" />
import { Connection } from '@d-fischer/connection';
import { LoggerOptions } from '@d-fischer/logger';
import { ResolvableValue } from '@d-fischer/shared-utils';
import { EventEmitter, Listener } from '@d-fischer/typed-event-emitter';
import { Capability, ServerCapability } from './Capability/Capability';
import { Message, MessageConstructor, MessageParamValues } from './Message/Message';
import { MessageCollector } from './Message/MessageCollector';
import { NickChange, Notice, PrivateMessage } from './Message/MessageTypes/Commands';
import { ServerProperties } from './ServerProperties';
export declare type EventHandler<T extends Message = Message> = (message: T) => void;
export declare type EventHandlerList<T extends Message = Message> = Map<string, EventHandler<T>>;
export interface IRCCredentials {
    nick: string;
    password?: string;
    userName?: string;
    realName?: string;
}
export interface IRCClientConnectionOptions {
    hostName: string;
    port?: number;
    secure?: boolean;
    pingOnInactivity?: number;
    pingTimeout?: number;
    reconnect?: boolean;
}
export interface IRCClientOptions {
    connection: IRCClientConnectionOptions;
    credentials: IRCCredentials;
    channels?: ResolvableValue<string[]>;
    webSocket?: boolean;
    channelTypes?: string;
    logger?: Partial<LoggerOptions>;
    nonConformingCommands?: string[];
}
export declare class IrcClient extends EventEmitter {
    protected _connection: Connection;
    protected _registered: boolean;
    protected _options: IRCClientOptions;
    protected _credentials: IRCCredentials;
    protected _supportsCapabilities: boolean;
    protected _events: Map<string, EventHandlerList>;
    protected _registeredMessageTypes: Map<string, MessageConstructor>;
    onConnect: (handler: () => void) => Listener;
    onRegister: (handler: () => void) => Listener;
    onDisconnect: (handler: (manually: boolean, reason?: Error) => void) => Listener;
    onPrivmsg: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onAction: (handler: (target: string, user: string, message: string, msg: PrivateMessage) => void) => Listener;
    onNotice: (handler: (target: string, user: string, message: string, msg: Notice) => void) => Listener;
    onNickChange: (handler: (oldNick: string | undefined, newNick: string, msg: NickChange) => void) => Listener;
    onCtcp: (handler: (target: string, user: string, command: string, params: string, msg: PrivateMessage) => void) => Listener;
    onCtcpReply: (handler: (target: string, user: string, command: string, params: string, msg: Notice) => void) => Listener;
    onAnyMessage: (handler: (msg: Message) => void) => Listener;
    protected _serverProperties: ServerProperties;
    protected _supportedFeatures: {
        [feature: string]: true | string;
    };
    protected _collectors: MessageCollector[];
    protected _clientCapabilities: Map<string, Capability>;
    protected _serverCapabilities: Map<string, ServerCapability>;
    protected _negotiatedCapabilities: Map<string, ServerCapability>;
    protected _pingOnInactivity: number;
    protected _pingTimeout: number;
    protected _pingCheckTimer?: NodeJS.Timer;
    protected _pingTimeoutTimer?: NodeJS.Timer;
    protected _currentNick: string;
    private readonly _logger;
    private _initialConnectionSetupDone;
    constructor(options: IRCClientOptions);
    receiveLine(line: string): void;
    get serverProperties(): ServerProperties;
    get port(): number;
    pingCheck(): void;
    reconnect(message?: string): Promise<void>;
    registerMessageType(cls: MessageConstructor): void;
    knowsCommand(command: string): boolean;
    getCommandClass(command: string): MessageConstructor | undefined;
    connect(): Promise<void>;
    waitForRegistration(): Promise<void>;
    addCapability(cap: Capability): void;
    registerCapability(cap: Capability): Promise<Error | ServerCapability[]>;
    send(message: Message): void;
    sendRaw(line: string): void;
    onNamedMessage<T extends Message = Message>(commandName: string, handler: EventHandler<T>, handlerName?: string): string;
    onTypedMessage<T extends Message>(type: MessageConstructor<T>, handler: EventHandler<T>, handlerName?: string): string;
    removeMessageListener(handlerName: string): void;
    createMessage<T extends Message<T>>(type: MessageConstructor<T>, params: Partial<MessageParamValues<T>>, tags?: Record<string, string>): T;
    sendMessage<T extends Message<T>>(type: MessageConstructor<T>, params: Partial<MessageParamValues<T>>, tags?: Record<string, string>): void;
    sendMessageAndCaptureReply<T extends Message<T>>(type: MessageConstructor<T>, params: Partial<MessageParamValues<T>>): Promise<Message[]>;
    get isConnected(): boolean;
    get isConnecting(): boolean;
    get isRegistered(): boolean;
    get currentNick(): string;
    /** @private */
    collect(originalMessage: Message, ...types: MessageConstructor[]): MessageCollector;
    /** @private */
    stopCollect(collector: MessageCollector): void;
    join(channel: string, key?: string): void;
    part(channel: string): void;
    quit(message?: string): Promise<void>;
    say(target: string, message: string, tags?: Record<string, string>): void;
    sendCtcp(target: string, type: string, message: string): void;
    action(target: string, message: string): void;
    protected getPassword(currentPassword?: string): Promise<string | undefined>;
    protected registerCoreMessageTypes(): void;
    protected _negotiateCapabilityBatch(capabilities: ServerCapability[][]): Promise<Array<ServerCapability[] | Error>>;
    protected _negotiateCapabilities(capList: ServerCapability[]): Promise<ServerCapability[] | Error>;
    protected _updateCredentials(newCredentials: Partial<IRCCredentials>): void;
    private _setupConnection;
    private _handleReceivedClientNick;
    private _handleEvents;
    private _startPingCheckTimer;
}
