"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = exports.createMessage = exports.prefixToString = void 0;
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var NotEnoughParametersError_1 = require("../Errors/NotEnoughParametersError");
var ParameterRequirementMismatchError_1 = require("../Errors/ParameterRequirementMismatchError");
var ServerProperties_1 = require("../ServerProperties");
var StringTools_1 = require("../Toolkit/StringTools");
var tagEscapeMap = {
    '\\': '\\',
    ';': ':',
    '\n': 'n',
    '\r': 'r',
    ' ': 's'
};
function escapeTag(str) {
    return str.replace(/[\\;\n\r ]/g, function (match) { return "\\" + tagEscapeMap[match]; });
}
function prefixToString(prefix) {
    var result = "" + prefix.nick;
    if (prefix.user) {
        result += "!" + prefix.user;
    }
    if (prefix.host) {
        result += "@" + prefix.host;
    }
    return result;
}
exports.prefixToString = prefixToString;
function createMessage(type, params, prefix, tags, serverProperties, isServer) {
    if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
    if (isServer === void 0) { isServer = false; }
    var message = new type(type.COMMAND, undefined, undefined, undefined, serverProperties);
    var parsedParams = {};
    shared_utils_1.forEachObjectEntry(type.PARAM_SPEC, function (paramSpec, paramName) {
        if (isServer && paramSpec.noServer) {
            return;
        }
        if (!isServer && paramSpec.noClient) {
            return;
        }
        if (paramName in params) {
            var param = params[paramName];
            if (param !== undefined) {
                if (type.checkParam(param, paramSpec, serverProperties)) {
                    parsedParams[paramName] = {
                        value: param,
                        trailing: Boolean(paramSpec.trailing)
                    };
                }
                else if (!paramSpec.optional) {
                    throw new Error("required parameter \"" + paramName + "\" did not suit requirements: \"" + param + "\"");
                }
            }
        }
        if (!(paramName in parsedParams) && !paramSpec.optional) {
            throw new Error("required parameter \"" + paramName + "\" not found in command \"" + type.COMMAND + "\"");
        }
    });
    Object.assign(message, parsedParams);
    message._initPrefixAndTags(prefix, tags);
    return message;
}
exports.createMessage = createMessage;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
var Message = /** @class */ (function () {
    function Message(command, params, tags, prefix, serverProperties, rawLine, isServer, shouldParseParams) {
        if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
        if (isServer === void 0) { isServer = false; }
        if (shouldParseParams === void 0) { shouldParseParams = true; }
        this._params = [];
        this._serverProperties = ServerProperties_1.defaultServerProperties;
        this._command = command;
        this._params = params;
        this._tags = tags || new Map();
        this._prefix = prefix;
        this._serverProperties = serverProperties;
        this._raw = rawLine;
        if (shouldParseParams) {
            this.parseParams(isServer);
        }
    }
    Message.checkParam = function (param, spec, serverProperties) {
        if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
        if (spec.type === 'channel') {
            if (!StringTools_1.isChannel(param, serverProperties.channelTypes)) {
                return false;
            }
        }
        if (spec.type === 'channelList') {
            var channels = param.split(',');
            if (!channels.every(function (chan) { return StringTools_1.isChannel(chan, serverProperties.channelTypes); })) {
                return false;
            }
        }
        if (spec.match) {
            if (!spec.match.test(param)) {
                return false;
            }
        }
        return true;
    };
    Message.getMinParamCount = function (isServer) {
        if (isServer === void 0) { isServer = false; }
        if (!this.PARAM_SPEC) {
            return 0;
        }
        return Object.values(this.PARAM_SPEC).filter(function (spec) {
            if (spec.noServer && isServer) {
                return false;
            }
            if (spec.noClient && !isServer) {
                return false;
            }
            return !spec.optional;
        }).length;
    };
    Message.prototype.prefixToString = function () {
        if (!this._prefix) {
            return '';
        }
        return prefixToString(this._prefix);
    };
    Message.prototype.tagsToString = function () {
        if (!this._tags) {
            return '';
        }
        return tslib_1.__spread(this._tags.entries()).map(function (_a) {
            var _b = tslib_1.__read(_a, 2), key = _b[0], value = _b[1];
            return (value ? key + "=" + escapeTag(value) : key);
        }).join(';');
    };
    Message.prototype.toString = function (complete) {
        var _this = this;
        if (complete === void 0) { complete = false; }
        var cls = this.constructor;
        var specKeys = Object.keys(cls.PARAM_SPEC);
        var fullCommand = tslib_1.__spread([
            this._command
        ], specKeys
            .map(function (paramName) {
            // TS inference does really not help here... so this is any for now
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var param = _this[paramName];
            if (param) {
                return (param.trailing ? ':' : '') + param.value;
            }
            return undefined;
        })
            .filter(function (param) { return param !== undefined; })).join(' ');
        if (!complete) {
            return fullCommand;
        }
        var parts = [fullCommand];
        var prefix = this.prefixToString();
        if (prefix) {
            parts.unshift(":" + prefix);
        }
        var tags = this.tagsToString();
        if (tags) {
            parts.unshift("@" + tags);
        }
        return parts.join(' ');
    };
    /** @private */
    Message.prototype._initPrefixAndTags = function (prefix, tags) {
        this._prefix = prefix;
        if (tags) {
            this._tags = tags;
        }
    };
    Message.prototype.parseParams = function (isServer) {
        var e_1, _a;
        if (isServer === void 0) { isServer = false; }
        if (this._params) {
            var cls = this.constructor;
            var requiredParamsLeft = cls.getMinParamCount(isServer);
            if (requiredParamsLeft > this._params.length) {
                throw new NotEnoughParametersError_1.NotEnoughParametersError(this._command, requiredParamsLeft, this._params.length);
            }
            var paramSpecList = cls.PARAM_SPEC;
            if (!paramSpecList) {
                return;
            }
            var i = 0;
            var parsedParams = {};
            try {
                for (var _b = tslib_1.__values(Object.entries(paramSpecList)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = tslib_1.__read(_c.value, 2), paramName = _d[0], paramSpec = _d[1];
                    if (paramSpec.noServer && isServer) {
                        continue;
                    }
                    if (paramSpec.noClient && !isServer) {
                        continue;
                    }
                    if (this._params.length - i <= requiredParamsLeft) {
                        if (paramSpec.optional) {
                            continue;
                        }
                        else if (this._params.length - i !== requiredParamsLeft) {
                            throw new Error('not enough parameters left for required parameters parsing (this is a library bug)');
                        }
                    }
                    var param = this._params[i];
                    if (!param) {
                        if (paramSpec.optional) {
                            break;
                        }
                        throw new Error('unexpected parameter underflow');
                    }
                    if (paramSpec.rest) {
                        var restParams = [];
                        while (this._params[i] && !this._params[i].trailing) {
                            restParams.push(this._params[i].value);
                            ++i;
                        }
                        if (!restParams.length) {
                            if (paramSpec.optional) {
                                continue;
                            }
                            throw new Error("no parameters left for required rest parameter \"" + paramName + "\"");
                        }
                        param = {
                            value: restParams.join(' '),
                            trailing: false
                        };
                    }
                    if (Message.checkParam(param.value, paramSpec)) {
                        parsedParams[paramName] = tslib_1.__assign({}, param);
                        if (!paramSpec.optional) {
                            --requiredParamsLeft;
                        }
                        if (!paramSpec.rest) {
                            ++i;
                        }
                    }
                    else if (!paramSpec.optional) {
                        throw new ParameterRequirementMismatchError_1.ParameterRequirementMismatchError(this._command, paramName, paramSpec, param.value);
                    }
                    if (paramSpec.trailing) {
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            Object.assign(this, parsedParams);
        }
    };
    Object.defineProperty(Message.prototype, "params", {
        get: function () {
            var _this = this;
            var cls = this.constructor;
            var specKeys = Object.keys(cls.PARAM_SPEC);
            return Object.assign.apply(Object, tslib_1.__spread([{}], specKeys
                .map(function (paramName) {
                // TS inference does really not help here... so this is any for now
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var param = _this[paramName];
                if (param) {
                    return [paramName, param.value];
                }
                return undefined;
            })
                .filter(function (pair) { return pair !== undefined; })
                .map(function (_a) {
                var _b;
                var _c = tslib_1.__read(_a, 2), key = _c[0], value = _c[1];
                return (_b = {}, _b[key] = value, _b);
            })));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "prefix", {
        get: function () {
            return this._prefix;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "command", {
        get: function () {
            return this._command;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "tags", {
        get: function () {
            return this._tags;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Message.prototype, "rawLine", {
        get: function () {
            return this._raw;
        },
        enumerable: false,
        configurable: true
    });
    Message.prototype.isResponseTo = function (originalMessage) {
        return false;
    };
    Message.prototype.endsResponseTo = function (originalMessage) {
        return false;
    };
    Message.prototype._acceptsInReplyCollection = function (message) {
        // TODO implement IRCv3 labeled-response / batch here
        return message.isResponseTo(this);
    };
    Message.COMMAND = '';
    Message.SUPPORTS_CAPTURE = false;
    return Message;
}());
exports.Message = Message;
