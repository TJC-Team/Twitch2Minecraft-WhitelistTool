"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseMessage = exports.parseTags = exports.parsePrefix = void 0;
var tslib_1 = require("tslib");
var shared_utils_1 = require("@d-fischer/shared-utils");
var ServerProperties_1 = require("../ServerProperties");
var Message_1 = require("./Message");
var MessageTypes_1 = require("./MessageTypes");
function parsePrefix(raw) {
    var _a = tslib_1.__read(shared_utils_1.splitWithLimit(raw, '!', 2), 2), nick = _a[0], hostName = _a[1];
    if (hostName) {
        var _b = tslib_1.__read(shared_utils_1.splitWithLimit(hostName, '@', 2), 2), user = _b[0], host = _b[1];
        if (host) {
            return { nick: nick, user: user, host: host };
        }
        else {
            return { nick: nick, host: user };
        }
    }
    else {
        return { nick: nick };
    }
}
exports.parsePrefix = parsePrefix;
var tagUnescapeMap = {
    ':': ';',
    n: '\n',
    r: '\r',
    s: ' '
};
function parseTags(raw) {
    var e_1, _a;
    var tags = new Map();
    var tagStrings = raw.split(';');
    try {
        for (var tagStrings_1 = tslib_1.__values(tagStrings), tagStrings_1_1 = tagStrings_1.next(); !tagStrings_1_1.done; tagStrings_1_1 = tagStrings_1.next()) {
            var tagString = tagStrings_1_1.value;
            var _b = tslib_1.__read(shared_utils_1.splitWithLimit(tagString, '=', 2), 2), tagName = _b[0], tagValue = _b[1];
            if (tagName === '') {
                continue; // Ignore empty tags: @ @; @x; etc.
            }
            // unescape according to http://ircv3.net/specs/core/message-tags-3.2.html#escaping-values
            tags.set(tagName, tagValue
                ? tagValue.replace(/\\(.?)/g, function (_, match) {
                    return Object.prototype.hasOwnProperty.call(tagUnescapeMap, match) ? tagUnescapeMap[match] : match;
                })
                : '');
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (tagStrings_1_1 && !tagStrings_1_1.done && (_a = tagStrings_1.return)) _a.call(tagStrings_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return tags;
}
exports.parseTags = parseTags;
function parseMessage(line, serverProperties, knownCommands, isServer, nonConformingCommands) {
    if (serverProperties === void 0) { serverProperties = ServerProperties_1.defaultServerProperties; }
    if (knownCommands === void 0) { knownCommands = MessageTypes_1.all; }
    if (isServer === void 0) { isServer = false; }
    if (nonConformingCommands === void 0) { nonConformingCommands = []; }
    var splitLine = line.split(' ');
    var token;
    var command;
    var params = [];
    var tags;
    var prefix;
    while (splitLine.length) {
        token = splitLine[0];
        if (token[0] === '@' && !tags && !command && !prefix) {
            tags = parseTags(token.substr(1));
        }
        else if (token[0] === ':') {
            if (!prefix && !command) {
                if (token.length > 1) {
                    // Not an empty prefix
                    prefix = parsePrefix(token.substr(1));
                }
            }
            else {
                params.push({
                    value: splitLine.join(' ').substr(1),
                    trailing: true
                });
                break;
            }
        }
        else if (command) {
            params.push({
                value: token,
                trailing: false
            });
        }
        else {
            command = token.toUpperCase();
        }
        splitLine.shift();
    }
    if (!tags) {
        tags = new Map();
    }
    if (!command) {
        throw new Error("line without command received: " + line);
    }
    var messageClass = Message_1.Message;
    if (knownCommands.has(command)) {
        messageClass = knownCommands.get(command);
    }
    return new messageClass(command, params, tags, prefix, serverProperties, line, isServer, !nonConformingCommands.includes(command));
}
exports.parseMessage = parseMessage;
